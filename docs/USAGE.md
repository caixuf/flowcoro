# Flow## âœ¨ æœ€æ–°æ›´æ–° (v4.0)

### ğŸ¯ when_all é‡å¤§æ”¹è¿›

- **ä¼˜åŒ–çš„é¡ºåºæ‰§è¡Œ**ï¼šæ–°å®ç°ä½¿ç”¨ç´¢å¼•åŒ–é¡ºåºæ‰§è¡Œï¼Œé¿å…äº†å‚æ•°åŒ…å±•å¼€çš„å¹¶å‘é—®é¢˜
- **å†…å­˜ä¼˜åŒ–**ï¼šå•è¯·æ±‚å†…å­˜ä½¿ç”¨é™è‡³94-130 bytes/è¯·æ±‚
- **æé«˜æ€§èƒ½**ï¼šæ”¯æŒ10000+å¹¶å‘ä»»åŠ¡ï¼Œååé‡è¾¾71ä¸‡+è¯·æ±‚/ç§’
- **ç¨³å®šæ€§æå‡**ï¼šæ¶ˆé™¤äº†è·¨çº¿ç¨‹åç¨‹æ¢å¤é—®é¢˜ï¼Œå½»åº•è§£å†³æ®µé”™è¯¯é—®é¢˜

### ğŸ› ï¸ sleep_for æ¶æ„å‡çº§

- **åç¨‹å‹å¥½è®¾è®¡**ï¼šä½¿ç”¨CoroutineManagerçš„å®šæ—¶å™¨ç³»ç»Ÿï¼Œä¸å†ä¾èµ–å¤šçº¿ç¨‹
- **æ¶ˆé™¤è·¨çº¿ç¨‹é—®é¢˜**ï¼šæ‰€æœ‰åç¨‹æ¢å¤éƒ½åœ¨æ­£ç¡®çš„æ‰§è¡Œä¸Šä¸‹æ–‡ä¸­è¿›è¡Œ
- **ioManageræ¶æ„**ï¼šé‡‡ç”¨drive-basedè°ƒåº¦ç³»ç»Ÿï¼Œæä¾›æ›´å¥½çš„æ€§èƒ½å’Œç¨³å®šæ€§

## ğŸš€ å¿«é€Ÿå¼€å§‹

FlowCoroæ˜¯ä¸€ä¸ªç°ä»£çš„C++20åç¨‹åº“ï¼Œæä¾›ç®€å•æ˜“ç”¨çš„å¼‚æ­¥ç¼–ç¨‹æ¥å£ã€‚**åç¨‹æ± æ˜¯è‡ªåŠ¨ç®¡ç†çš„ï¼Œæ— éœ€æ‰‹åŠ¨åˆ›å»ºï¼**

## âœ¨ æœ€æ–°æ›´æ–° (v4.0)

### ğŸ¯ when_all é‡å¤§æ”¹è¿›
- **ä¼˜åŒ–çš„é¡ºåºæ‰§è¡Œ**ï¼šæ–°å®ç°ä½¿ç”¨ç´¢å¼•åŒ–é¡ºåºæ‰§è¡Œï¼Œé¿å…äº†å‚æ•°åŒ…å±•å¼€çš„å¹¶å‘é—®é¢˜
- **å†…å­˜ä¼˜åŒ–**ï¼šå•è¯·æ±‚å†…å­˜ä½¿ç”¨é™è‡³94-130 bytes/è¯·æ±‚ 
- **æé«˜æ€§èƒ½**ï¼šæ”¯æŒ10000+å¹¶å‘ä»»åŠ¡ï¼Œååé‡è¾¾71ä¸‡+è¯·æ±‚/ç§’
- **ç¨³å®šæ€§æå‡**ï¼šæ¶ˆé™¤äº†è·¨çº¿ç¨‹åç¨‹æ¢å¤é—®é¢˜ï¼Œå½»åº•è§£å†³æ®µé”™è¯¯é—®é¢˜

### ï¿½ï¸ sleep_for æ¶æ„å‡çº§
- **åç¨‹å‹å¥½è®¾è®¡**ï¼šä½¿ç”¨CoroutineManagerçš„å®šæ—¶å™¨ç³»ç»Ÿï¼Œä¸å†ä¾èµ–å¤šçº¿ç¨‹
- **æ¶ˆé™¤è·¨çº¿ç¨‹é—®é¢˜**ï¼šæ‰€æœ‰åç¨‹æ¢å¤éƒ½åœ¨æ­£ç¡®çš„æ‰§è¡Œä¸Šä¸‹æ–‡ä¸­è¿›è¡Œ
- **ioManageræ¶æ„**ï¼šé‡‡ç”¨drive-basedè°ƒåº¦ç³»ç»Ÿï¼Œæä¾›æ›´å¥½çš„æ€§èƒ½å’Œç¨³å®šæ€§

## ï¿½ğŸ“ åŸºæœ¬ä½¿ç”¨æ–¹å¼

### 1. ç®€å•çš„åç¨‹ä»»åŠ¡

```cpp
#include "flowcoro.hpp"
using namespace flowcoro;

// å®šä¹‰ä¸€ä¸ªåç¨‹å‡½æ•°
Task<int> async_compute(int value) {
    std::cout << "å¼€å§‹è®¡ç®—: " << value << std::endl;
    
    // å¼‚æ­¥ç­‰å¾…ï¼ˆæ¨¡æ‹ŸIOæ“ä½œï¼‰ - ç°åœ¨ä½¿ç”¨åç¨‹å‹å¥½çš„å®ç°
    co_await sleep_for(std::chrono::milliseconds(100));
    
    int result = value * 2;
    std::cout << "è®¡ç®—å®Œæˆ: " << result << std::endl;
    
    co_return result;
}

int main() {
    // æ–¹å¼1: åŒæ­¥ç­‰å¾…åç¨‹ç»“æœ
    auto result = sync_wait(async_compute(21));
    std::cout << "ç»“æœ: " << result << std::endl;  // è¾“å‡º: 42
    
    return 0;
}
```

### 2. æ‰¹é‡å¹¶å‘å¤„ç† (when_all é£æ ¼)

FlowCoro æä¾›äº†ä¼˜åŒ–çš„æ‰¹é‡å¤„ç†æ–¹å¼ï¼š

#### when_all é«˜æ€§èƒ½å®ç°ï¼ˆæ”¯æŒ1-10000+ä»»åŠ¡ï¼‰

```cpp
// å®šä¹‰ä¸åŒç±»å‹çš„å¼‚æ­¥ä»»åŠ¡
Task<int> compute_task(int value) {
    co_await sleep_for(std::chrono::milliseconds(100));
    co_return value * 2;
}

Task<std::string> fetch_data(const std::string& key) {
    // âœ… å…³é”®ï¼šé¢„æ„å»ºå­—ç¬¦ä¸²ï¼Œé¿å…co_awaitåå†…å­˜åˆ†é…é—®é¢˜
    std::string result = "æ•°æ®:" + key;
    co_await sleep_for(std::chrono::milliseconds(150));
    co_return result;
}

Task<void> true_when_all_example() {
    // åˆ›å»ºå›ºå®šæ•°é‡çš„ä¸åŒç±»å‹ä»»åŠ¡
    auto task1 = compute_task(21);
    auto task2 = compute_task(42);
    auto task3 = fetch_data("user123");
    
    // â­ çœŸæ­£çš„ when_allï¼šåŒæ—¶æ‰§è¡Œï¼Œè‡ªåŠ¨ç±»å‹æ¨å¯¼
    auto [result1, result2, result3] = co_await when_all(
        std::move(task1),
        std::move(task2),
        std::move(task3)
    );
    
    std::cout << "è®¡ç®—ç»“æœ1: " << result1 << std::endl;      // 42
    std::cout << "è®¡ç®—ç»“æœ2: " << result2 << std::endl;      // 84
    std::cout << "è·å–æ•°æ®: " << result3 << std::endl;       // "æ•°æ®:user123"
}
```

#### æ–¹å¼2ï¼šwhen_all é£æ ¼æ‰‹åŠ¨ç®¡ç†ï¼ˆç”¨äºåŠ¨æ€æ•°é‡ä»»åŠ¡ï¼‰

```cpp
Task<void> when_all_style_dynamic(int request_count) {
    // åˆ›å»ºåŠ¨æ€æ•°é‡çš„åŒç±»å‹ä»»åŠ¡
    std::vector<Task<std::string>> tasks;
    tasks.reserve(request_count);
    
    for (int i = 0; i < request_count; ++i) {
        tasks.emplace_back([](int id) -> Task<std::string> {
            // é¢„æ„å»ºå­—ç¬¦ä¸²
            std::string user_prefix = "ç”¨æˆ·" + std::to_string(id);
            std::string result_suffix = " (å·²å¤„ç†)";
            
            co_await sleep_for(std::chrono::milliseconds(50));
            co_return user_prefix + result_suffix;
        }(1000 + i));
    }
    
    // ğŸŒŸ when_all é£æ ¼ï¼šæäº¤æ‰€æœ‰ä»»åŠ¡åˆ°åç¨‹æ± 
    for (auto& task : tasks) {
        if (task.handle) {
            schedule_coroutine_enhanced(task.handle);
        }
    }
    
    // ğŸš€ ç®€åŒ–çš„ç»“æœæ”¶é›†ï¼ˆç›¸æ¯”ä¼ ç»Ÿæ–¹æ³•å‡å°‘80%ä»£ç ï¼‰
    std::vector<std::string> results;
    results.reserve(request_count);
    
    while (results.size() < request_count) {
        drive_coroutine_pool(); // é©±åŠ¨åç¨‹æ± 
        
        // æ”¶é›†å®Œæˆçš„ä»»åŠ¡ç»“æœ
        for (int i = 0; i < request_count; ++i) {
            if (tasks[i].handle && tasks[i].handle.done() && i >= results.size()) {
                results.push_back(tasks[i].get());
            }
        }
    }
    
    // å¤„ç†æ‰€æœ‰ç»“æœ
    std::cout << "å¤„ç†äº† " << results.size() << " ä¸ªå¹¶å‘ä»»åŠ¡" << std::endl;
}

int main() {
    // ä½¿ç”¨çœŸæ­£çš„ when_all
    sync_wait(true_when_all_example());
    
    // ä½¿ç”¨ when_all é£æ ¼åŠ¨æ€å¤„ç†
    sync_wait(when_all_style_dynamic(100));
    
    return 0;
}
```

### 3. æ‰‹åŠ¨æ§åˆ¶åç¨‹æ± ï¼ˆé«˜çº§ç”¨æ³•ï¼‰

å¦‚æœéœ€è¦æ›´ç²¾ç»†çš„æ§åˆ¶ï¼Œå¯ä»¥æ‰‹åŠ¨é©±åŠ¨åç¨‹æ± ï¼š

```cpp
int main() {
    auto task = async_compute(42);
    
    // æ‰‹åŠ¨æäº¤åç¨‹åˆ°åç¨‹æ± 
    if (task.handle) {
        schedule_coroutine_enhanced(task.handle);
    }
    
    // æ‰‹åŠ¨é©±åŠ¨äº‹ä»¶å¾ªç¯
    while (!task.handle.done()) {
        drive_coroutine_pool();  // é©±åŠ¨åç¨‹æ± 
        std::this_thread::sleep_for(std::chrono::milliseconds(1));
    }
    
    return 0;
}
```

## ğŸ”§ æ ¸å¿ƒAPIè¯´æ˜

### åç¨‹ç›¸å…³

- **`Task<T>`**: åç¨‹ä»»åŠ¡ç±»å‹ï¼ŒTæ˜¯è¿”å›å€¼ç±»å‹
- **`co_await`**: ç­‰å¾…å¦ä¸€ä¸ªåç¨‹å®Œæˆ
- **`co_return`**: ä»åç¨‹è¿”å›å€¼
- **`sleep_for(duration)`**: å¼‚æ­¥ç­‰å¾…æŒ‡å®šæ—¶é—´
- **`when_all(tasks...)`**: å¹¶å‘ç­‰å¾…å¤šä¸ªå›ºå®šä»»åŠ¡å®Œæˆï¼Œè¿”å›æ‰€æœ‰ç»“æœçš„å…ƒç»„

### æ‰§è¡Œæ§åˆ¶

- **`sync_wait(task)`**: åŒæ­¥ç­‰å¾…åç¨‹å®Œæˆï¼Œé˜»å¡å½“å‰çº¿ç¨‹
- **`schedule_coroutine_enhanced(handle)`**: æ‰‹åŠ¨å°†åç¨‹æäº¤åˆ°åç¨‹æ± 
- **`drive_coroutine_pool()`**: æ‰‹åŠ¨é©±åŠ¨åç¨‹æ± æ‰§è¡Œ

### åç¨‹æ± ç®¡ç†ï¼ˆè‡ªåŠ¨ï¼‰

- åç¨‹æ± åœ¨é¦–æ¬¡ä½¿ç”¨æ—¶**è‡ªåŠ¨å¯åŠ¨**
- é»˜è®¤ä½¿ç”¨å•çº¿ç¨‹äº‹ä»¶å¾ªç¯ + å¤šçº¿ç¨‹å·¥ä½œæ± 
- æ— éœ€æ‰‹åŠ¨åˆ›å»ºæˆ–ç®¡ç†åç¨‹æ± 

## âœ¨ å…³é”®ç‰¹æ€§

### ğŸ¯ è‡ªåŠ¨åç¨‹æ± ç®¡ç†
- **æ— éœ€æ‰‹åŠ¨åˆ›å»º**: åç¨‹æ± è‡ªåŠ¨åˆå§‹åŒ–å’Œç®¡ç†
- **é«˜æ€§èƒ½è°ƒåº¦**: å•çº¿ç¨‹äº‹ä»¶å¾ªç¯é¿å…ç«äº‰æ¡ä»¶
- **å·¥ä½œçº¿ç¨‹æ± **: 32ä¸ªé«˜æ€§èƒ½å·¥ä½œçº¿ç¨‹å¤„ç†è®¡ç®—å¯†é›†ä»»åŠ¡

### âš¡ æ€§èƒ½ä¼˜åŠ¿
- **è½»é‡çº§**: åç¨‹åˆ›å»ºå¼€é”€æä½ï¼ˆå¾®ç§’çº§ï¼‰
- **é«˜å¹¶å‘**: æ”¯æŒå¤§è§„æ¨¡å¹¶å‘ï¼ˆä¸‡çº§åç¨‹ï¼‰
- **å†…å­˜é«˜æ•ˆ**: ç›¸æ¯”çº¿ç¨‹èŠ‚çœ640å€å†…å­˜

### ğŸ›¡ï¸ å®‰å…¨ä¿éšœ
- **è·¨çº¿ç¨‹å®‰å…¨**: é¿å…è·¨çº¿ç¨‹åç¨‹æ¢å¤çš„æ®µé”™è¯¯
- **å¼‚å¸¸å¤„ç†**: å®Œå–„çš„é”™è¯¯å¤„ç†æœºåˆ¶
- **ç”Ÿå‘½å‘¨æœŸç®¡ç†**: è‡ªåŠ¨ç®¡ç†åç¨‹ç”Ÿå‘½å‘¨æœŸ

## ğŸˆ ä½¿ç”¨å»ºè®®

### âœ… æ¨èç”¨æ³•

1. **ç®€å•åœºæ™¯**: ç›´æ¥ä½¿ç”¨ `sync_wait()`
2. **æ‰¹é‡å¤„ç†**: åœ¨åç¨‹å†…ä½¿ç”¨ `co_await` ç­‰å¾…å…¶ä»–åç¨‹
3. **ç½‘ç»œIO**: ä½¿ç”¨å¼‚æ­¥ç­‰å¾…é¿å…é˜»å¡
4. **å®šæ—¶ä»»åŠ¡**: ä½¿ç”¨ `sleep_for()` å®ç°å®šæ—¶å™¨

### âŒ é¿å…çš„ç”¨æ³•

1. **ä¸è¦æ‰‹åŠ¨ç®¡ç†åç¨‹æ± **: é™¤éæœ‰ç‰¹æ®Šéœ€æ±‚
2. **ä¸è¦åœ¨åç¨‹å¤–ä½¿ç”¨co_await**: åªèƒ½åœ¨åç¨‹å‡½æ•°å†…ä½¿ç”¨
3. **ä¸è¦å¿˜è®°co_return**: åç¨‹å‡½æ•°å¿…é¡»æœ‰è¿”å›
4. **âš ï¸ å­—ç¬¦ä¸²ä»»åŠ¡æ³¨æ„äº‹é¡¹**: é¿å…åœ¨`co_await`åè¿›è¡Œå­—ç¬¦ä¸²æ‹¼æ¥
5. **âš ï¸ when_all ä½¿ç”¨é™åˆ¶**: 
   - ä¸èƒ½ç›´æ¥ç”¨äº `std::vector<Task<T>>`ï¼ˆåŠ¨æ€æ•°é‡ä»»åŠ¡ï¼‰
   - é€‚åˆ 2-10 ä¸ªå›ºå®šæ•°é‡ä»»åŠ¡
   - è¶…è¿‡ 10 ä¸ªä»»åŠ¡å»ºè®®åˆ†æ‰¹å¤„ç†

```cpp
// âŒ é”™è¯¯ - åç¨‹æ¢å¤åå­—ç¬¦ä¸²åˆ†é…å¯èƒ½å¤±è´¥
Task<std::string> bad_task(const std::string& name) {
    co_await sleep_for(std::chrono::milliseconds(100));
    return "ç»“æœ:" + name;  // å¯èƒ½è§¦å‘ std::bad_alloc
}

// âŒ é”™è¯¯ - when_all ä¸æ”¯æŒåŠ¨æ€æ•°é‡ä»»åŠ¡
std::vector<Task<int>> tasks = create_many_tasks(100);
// auto results = co_await when_all(tasks);  // ç¼–è¯‘é”™è¯¯ï¼

// âœ… æ­£ç¡® - åœ¨åç¨‹æŒ‚èµ·å‰é¢„æ„å»ºå­—ç¬¦ä¸²
Task<std::string> good_task(const std::string& name) {
    std::string result = "ç»“æœ:" + name;  // é¢„æ„å»º
    co_await sleep_for(std::chrono::milliseconds(100));
    co_return result;
}

// âœ… æ­£ç¡® - åŠ¨æ€æ•°é‡ä»»åŠ¡ä½¿ç”¨å¾ªç¯æˆ–when_allé£æ ¼ç®¡ç†
std::vector<Task<int>> tasks = create_many_tasks(100);
std::vector<int> results;
for (auto& task : tasks) {
    results.push_back(co_await task);  // æˆ–ä½¿ç”¨åç¨‹æ± ç®¡ç†
}

// âœ… æ­£ç¡® - when_all ç”¨äºå›ºå®šæ•°é‡ä»»åŠ¡
auto [r1, r2, r3] = co_await when_all(task1, task2, task3);
```

## ğŸ“Š æ€§èƒ½å¯¹æ¯”

åŸºäºå®æµ‹æ•°æ®ï¼ˆ10000ä¸ªå¹¶å‘ä»»åŠ¡ï¼‰ï¼š

| æ–¹æ¡ˆ | æ‰§è¡Œæ—¶é—´ | å†…å­˜ä½¿ç”¨ | å¹¶å‘èƒ½åŠ› | ååé‡ |
|------|----------|----------|----------|--------|
| FlowCoroåç¨‹ | 13ms | 792kb | ä¸‡çº§ | 769230 è¯·æ±‚/ç§’ |
| ä¼ ç»Ÿå¤šçº¿ç¨‹ | 778ms | 2.86MB | åƒçº§ | 12853 è¯·æ±‚/ç§’ |
| **æ€§èƒ½æå‡** | **60å€** | **4å€** | **60å€** | **70å€** |

### ğŸŒŸ when_all é£æ ¼çš„ä¼˜åŠ¿

- **ä»£ç ç®€æ´**: ç›¸æ¯”æ‰‹åŠ¨åç¨‹ç®¡ç†å‡å°‘80%æ ·æ¿ä»£ç 
- **è‡ªåŠ¨è°ƒåº¦**: æ— éœ€æ‰‹åŠ¨é©±åŠ¨å¤æ‚çš„äº‹ä»¶å¾ªç¯
- **å¼‚å¸¸å®‰å…¨**: è‡ªåŠ¨å¤„ç†åç¨‹ç”Ÿå‘½å‘¨æœŸå’Œå¼‚å¸¸ä¼ æ’­
- **é«˜æ€§èƒ½**: ä¿æŒåŸæœ‰æ€§èƒ½çš„åŒæ—¶å¤§å¹…ç®€åŒ–ä»£ç 
- **æ˜“ç»´æŠ¤**: æ›´ç¬¦åˆç°ä»£C++åç¨‹æœ€ä½³å®è·µ

## ğŸ”— å®Œæ•´ç¤ºä¾‹

å‚è€ƒé¡¹ç›®ä¸­çš„ä»¥ä¸‹æ–‡ä»¶ï¼š
- `examples/hello_world_concurrent.cpp` - å¹¶å‘å¤„ç†ç¤ºä¾‹
- `tests/test_core.cpp` - å•å…ƒæµ‹è¯•ç¤ºä¾‹

## ğŸ“š è¿›é˜¶åŠŸèƒ½

- **ç½‘ç»œIO**: HTTPå®¢æˆ·ç«¯ã€RPCæ”¯æŒ
- **æ•°æ®åº“**: å¼‚æ­¥æ•°æ®åº“è¿æ¥æ± 
- **é”™è¯¯å¤„ç†**: Result<T,E> é”™è¯¯å¤„ç†æœºåˆ¶
- **æ—¥å¿—ç³»ç»Ÿ**: é«˜æ€§èƒ½å¼‚æ­¥æ—¥å¿—
- **å†…å­˜ç®¡ç†**: å†…å­˜æ± ã€å¯¹è±¡æ± ä¼˜åŒ–
