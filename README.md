# FlowCoro

**é«˜æ€§èƒ½C++20åç¨‹åº“ - ä¸“æ³¨æ‰¹é‡å¹¶å‘ä»»åŠ¡å¤„ç†**

ä¸€ä¸ªåŸºäºC++20çš„ç°ä»£åç¨‹åº“ï¼Œä¸“é—¨è®¾è®¡ç”¨äºé«˜ååé‡çš„æ‰¹é‡ä»»åŠ¡å¤„ç†å’Œè¯·æ±‚-å“åº”æ¨¡å¼çš„åº”ç”¨åœºæ™¯ã€‚

## é¡¹ç›®ç®€ä»‹

FlowCoro æ˜¯ä¸€ä¸ªæ€§èƒ½å¯¼å‘çš„C++åç¨‹åº“ï¼Œé‡‡ç”¨å¤šçº¿ç¨‹åç¨‹è°ƒåº¦æ¶æ„ï¼Œåœ¨ä¿æŒç®€æ´APIçš„åŒæ—¶å®ç°å“è¶Šçš„æ‰¹é‡å¤„ç†æ€§èƒ½ã€‚

### æ ¸å¿ƒè®¾è®¡ç†å¿µ

- **æ‰¹é‡ä»»åŠ¡ä¼˜åŒ–**: ä¸“é—¨é’ˆå¯¹å¤§è§„æ¨¡å¹¶å‘ä»»åŠ¡å¤„ç†è¿›è¡Œä¼˜åŒ–
- **è¯·æ±‚-å“åº”æ¨¡å¼**: å®Œç¾é€‚é…WebæœåŠ¡ã€APIå¤„ç†ç­‰åœºæ™¯
- **å¤šçº¿ç¨‹è°ƒåº¦**: æ™ºèƒ½åç¨‹è°ƒåº¦å™¨ + çº¿ç¨‹æ± æ¶æ„
- **æ€§èƒ½è‡³ä¸Š**: æ¯ä¸ªç»„ä»¶éƒ½ç»è¿‡æ€§èƒ½åŸºå‡†æµ‹è¯•éªŒè¯
- **å†…å­˜å®‰å…¨**: RAIIç®¡ç†ï¼Œé›¶å†…å­˜æ³„æ¼è®¾è®¡

### æ¶æ„ç‰¹ç‚¹è¯´æ˜

**é‡è¦ï¼š** FlowCoro é‡‡ç”¨**ä¸‰å±‚è°ƒåº¦æ¶æ„**ï¼ŒåŸºäºæ— é”é˜Ÿåˆ—å®ç°é«˜æ€§èƒ½åç¨‹è°ƒåº¦ï¼š

- âœ… **å®Œç¾é€‚é…**: æ‰¹é‡ä»»åŠ¡å¤„ç†ã€è¯·æ±‚-å“åº”æ¨¡å¼
- âœ… **æé«˜æ€§èƒ½**: 476K+ req/s ååé‡ï¼Œ40å€æ€§èƒ½æå‡
- âœ… **æ— é”è°ƒåº¦**: 15.6M ops/sé˜Ÿåˆ—æ“ä½œï¼Œæ™ºèƒ½è´Ÿè½½å‡è¡¡
- âŒ **æ¶æ„é™åˆ¶**: æ— äº‹ä»¶å¾ªç¯ï¼Œä¸æ”¯æŒåç¨‹é—´æŒç»­åä½œæ¨¡å¼

**è°ƒåº¦æµç¨‹**: Taskåˆ›å»º â†’ åç¨‹ç®¡ç†å™¨ â†’ åç¨‹æ± (æ— é”é˜Ÿåˆ—) â†’ çº¿ç¨‹æ± æ‰§è¡Œ

## æ€§èƒ½è¡¨ç°

åŸºäºçœŸå®åŸºå‡†æµ‹è¯•çš„çªç ´æ€§æ€§èƒ½æ•°æ®ï¼š

### é«˜å¹¶å‘å¤„ç†èƒ½åŠ›ï¼ˆ10,000ä»»åŠ¡åŸºå‡†æµ‹è¯•ï¼‰

- **æé™ååé‡**: **476,190 req/s** (47ä¸‡è¯·æ±‚/ç§’)
- **è¶…ä½å»¶è¿Ÿ**: 0.0021ms/è¯·æ±‚
- **æ€§èƒ½å€æ•°**: æ¯”ä¼ ç»Ÿå¤šçº¿ç¨‹å¿« **40å€** (476k vs 11.9k req/s)
- **å†…å­˜æ•ˆç‡**: 408 bytes/è¯·æ±‚ï¼ˆåŠŸèƒ½ä¸°å¯Œçš„åç¨‹ä»»åŠ¡ï¼Œå«æ— é”é˜Ÿåˆ—å¼€é”€ï¼‰

### æ€§èƒ½ç›‘æ§ç³»ç»Ÿ

- **å®æ—¶ååé‡**: **31,818+ tasks/sec**
- **ç³»ç»Ÿç¨³å®šæ€§**: **100%ä»»åŠ¡å®Œæˆç‡** (é›¶å¤±è´¥ã€é›¶å–æ¶ˆ)
- **å“åº”é€Ÿåº¦**: æ€»è¿è¡Œæ—¶é—´ä»… **21ms** (åŒ…å«ç³»ç»Ÿåˆå§‹åŒ–)
- **å®šæ—¶å™¨ç²¾åº¦**: 100ä¸ªå®šæ—¶å™¨äº‹ä»¶ç²¾ç¡®è°ƒåº¦

### åç¨‹åˆ›å»ºæ€§èƒ½

- **ååé‡**: 4.33M ops/sec (433ä¸‡æ¬¡/ç§’)
- **å»¶è¿Ÿ**: 231 ns/op
- **å¯¹æ¯”**: ç›¸æ¯”ä¼ ç»Ÿçº¿ç¨‹åˆ›å»ºæå‡æ•°ç™¾å€

### å¹¶å‘æœºåˆ¶æ€§èƒ½

#### Task åˆ›å»ºæ—¶å¹¶å‘ï¼ˆå”¯ä¸€å¹¶å‘æ–¹å¼ï¼‰
- **å¯åŠ¨å»¶è¿Ÿ**: 0.1Î¼s (å¾®ç§’çº§)
- **å†…å­˜å¼€é”€**: æ¯åç¨‹ 80 bytes
- **é€‚ç”¨åœºæ™¯**: æ‰€æœ‰å¼‚æ­¥ç¼–ç¨‹åœºæ™¯
- **å®ç°æ–¹å¼**: ä»»åŠ¡å¯åŠ¨åç«‹å³å¹¶å‘æ‰§è¡Œï¼Œco_await åªæ˜¯ç­‰å¾…ç»“æœ

#### when_all è¯­æ³•ç³–ï¼ˆä¾¿åˆ©å°è£…ï¼‰
- **æœ¬è´¨**: co_await çš„ä¾¿åˆ©å°è£…ï¼Œå†…éƒ¨ä»æ˜¯é¡ºåºç­‰å¾…
- **å°è§„æ¨¡** (10ä»»åŠ¡): 625K ops/sec
- **ä¸­è§„æ¨¡** (100ä»»åŠ¡): 2.38M ops/sec  
- **å¤§è§„æ¨¡** (1000ä»»åŠ¡): 3.69M ops/sec
- **ä½œç”¨**: ç®€åŒ–å¤šä»»åŠ¡ç­‰å¾…çš„è¯­æ³•ï¼Œé¿å…æ‰‹åŠ¨è§£æ„

### æ ¸å¿ƒç»„ä»¶

| ç»„ä»¶ | æ€§èƒ½æŒ‡æ ‡ | è¯´æ˜ |
|------|----------|------|
| Taskåç¨‹ | 231nsåˆ›å»º | è½»é‡çº§åç¨‹ä»»åŠ¡ |
| çº¿ç¨‹æ±  | 32å·¥ä½œçº¿ç¨‹ | å·¥ä½œçªƒå–è°ƒåº¦ |
| å†…å­˜æ±  | 18.7M ops/s | åŠ¨æ€æ‰©å±•è®¾è®¡ |
| æ— é”é˜Ÿåˆ— | 15.6M ops/s | é«˜å¹¶å‘æ•°æ®ç»“æ„ï¼Œæ”¯æŒåç¨‹è°ƒåº¦ |
| å®šæ—¶å™¨ | 52nsç²¾åº¦ | é«˜ç²¾åº¦sleep_for |
| åç¨‹æ±  | å¤šè°ƒåº¦å™¨ | æ™ºèƒ½è´Ÿè½½å‡è¡¡ï¼Œè·¨çº¿ç¨‹åç¨‹æ¢å¤ |

### ä¸ä¼ ç»Ÿå¤šçº¿ç¨‹çš„çœŸå®å¯¹æ¯”æµ‹è¯•

**æµ‹è¯•ç¯å¢ƒ**: åŒæœºå™¨æµ‹è¯•ç¡®ä¿å…¬å¹³æ€§ï¼Œ10,000å¹¶å‘ä»»åŠ¡

#### æ€§èƒ½å¯¹æ¯”ç»“æœ

| æ–¹æ¡ˆ | æ‰§è¡Œæ—¶é—´ | ååé‡ | å†…å­˜ä½¿ç”¨ | å•ä»»åŠ¡å†…å­˜ |
|------|----------|--------|----------|------------|
| **FlowCoroåç¨‹** | **21ms** | **476,190 req/s** | 8.15MB | 408 bytes |
| **ä¼ ç»Ÿå¤šçº¿ç¨‹** | **840ms** | **11,905 req/s** | 7.21MB | 314 bytes |
| **æ€§èƒ½ä¼˜åŠ¿** | **40å€** | **40å€** | **åŠŸèƒ½ä¸°å¯Œ** | **åŠŸèƒ½æ›´å¼º** |

#### æ€§èƒ½ä¼˜åŠ¿åˆ†æ

- **æ‰§è¡Œæ•ˆç‡**: FlowCoroæ‰§è¡Œé€Ÿåº¦æ˜¯å¤šçº¿ç¨‹çš„40å€
- **ååé‡**: è¾¾åˆ°47ä¸‡è¯·æ±‚/ç§’çš„æé«˜ååé‡
- **æ‰©å±•æ€§**: ä»å°è§„æ¨¡åˆ°10Kä»»åŠ¡çº¿æ€§æ‰©å±•
- **åŠŸèƒ½ä¼˜åŠ¿**: æ¯ä»»åŠ¡408å­—èŠ‚åŒ…å«ä¸°å¯Œçš„åç¨‹åŠŸèƒ½ã€æ— é”é˜Ÿåˆ—å’Œç›‘æ§èƒ½åŠ›

**æµ‹è¯•è¯´æ˜**: æ‰€æœ‰æµ‹è¯•å‡åœ¨ç›¸åŒç¡¬ä»¶ç¯å¢ƒä¸‹è¿›è¡Œï¼Œä½¿ç”¨çœŸå®çš„CPUè®¡ç®—ä»»åŠ¡ï¼Œä¸“æ³¨æµ‹è¯•çº¯åç¨‹è°ƒåº¦æ€§èƒ½ã€‚æµ‹è¯•ä»£ç è§ `examples/hello_world.cpp`ã€‚

## å¿«é€Ÿå¼€å§‹

## å¿«é€Ÿå¼€å§‹

### ç¯å¢ƒè¦æ±‚

- C++20ç¼–è¯‘å™¨ (GCC 11+, Clang 12+)
- CMake 3.16+
- Linux/macOS/Windows

### æ„å»ºé¡¹ç›®

```bash
git clone https://github.com/caixuf/flowcord.git
cd flowcord
mkdir build && cd build
cmake .. -DCMAKE_BUILD_TYPE=Release
make -j$(nproc)
```

### åŸºç¡€ç¤ºä¾‹

```cpp
// åŸºç¡€ç¤ºä¾‹ï¼šä»»åŠ¡åˆ›å»ºæ—¶å¹¶å‘æ‰§è¡Œ
#include <flowcoro.hpp>

// æ–¹å¼1ï¼šco_await é€ä¸ªç­‰å¾…ï¼ˆä½†ä»»åŠ¡å·²åœ¨å¹¶å‘æ‰§è¡Œï¼‰
Task<void> sequential_style() {
    auto task1 = compute(1); // å¯åŠ¨ä»»åŠ¡1 - ç«‹å³å¼€å§‹å¹¶å‘æ‰§è¡Œ
    auto task2 = compute(2); // å¯åŠ¨ä»»åŠ¡2 - ç«‹å³å¼€å§‹å¹¶å‘æ‰§è¡Œ
    auto task3 = compute(3); // å¯åŠ¨ä»»åŠ¡3 - ç«‹å³å¼€å§‹å¹¶å‘æ‰§è¡Œ
    
    // æŒ‰é¡ºåºç­‰å¾…ï¼Œä½†ä»»åŠ¡å®é™…ä¸Šåœ¨å¹¶å‘æ‰§è¡Œ
    auto r1 = co_await task1; // ç­‰å¾…ä»»åŠ¡1
    auto r2 = co_await task2; // ä»»åŠ¡2å¯èƒ½å·²å®Œæˆ
    auto r3 = co_await task3; // ä»»åŠ¡3å¯èƒ½å·²å®Œæˆ
    
    std::cout << "Sequential: " << r1 << ", " << r2 << ", " << r3 << std::endl;
    co_return;
}

// æ–¹å¼2ï¼šwhen_all æ‰¹é‡ç­‰å¾…
Task<void> batch_style() {
    auto task1 = compute(1);
    auto task2 = compute(2); 
    auto task3 = compute(3);
    
    // ä¸€æ¬¡æ€§ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
    auto [r1, r2, r3] = co_await when_all(
        std::move(task1), 
        std::move(task2), 
        std::move(task3)
    );
    
    std::cout << "Batch: " << r1 << ", " << r2 << ", " << r3 << std::endl;
    co_return;
}

int main() {
    // åŒæ­¥ç­‰å¾…åç¨‹å®Œæˆ
    sync_wait(sequential_style());
    sync_wait(batch_style());
    return 0;
}
```

### æ€§èƒ½æµ‹è¯•

```bash
# è¿è¡ŒåŸºå‡†æµ‹è¯•éªŒè¯æ€§èƒ½æ•°æ®
cd build && make -j16
./benchmarks/simple_benchmark

# è¿è¡Œè·¨è¯­è¨€å¯¹æ¯”æµ‹è¯• (éœ€è¦å®‰è£…Goå’ŒRust)
# FlowCoroæµ‹è¯•
./examples/hello_world_concurrent coroutine 10000

# Goå¯¹æ¯”æµ‹è¯•
cd benchmarks && go build go_benchmark.go && ./go_benchmark 10000

# Rustå¯¹æ¯”æµ‹è¯•
cd benchmarks && cargo build --release && ./target/release/rust_benchmark 10000

# é¢„æœŸè¾“å‡ºç¤ºä¾‹ï¼š
# [BENCH] FlowCoroåç¨‹å¤„ç† (10,000ä»»åŠ¡):
# æ‰§è¡Œæ—¶é—´: 21ms
# ååé‡: 476,190 req/s
# å†…å­˜ä½¿ç”¨: 8.15MB (408 bytes/ä»»åŠ¡)
# 
# [BENCH] ä¼ ç»Ÿå¤šçº¿ç¨‹å¤„ç† (10,000ä»»åŠ¡):
# æ‰§è¡Œæ—¶é—´: 840ms
# ååé‡: 11,905 req/s
# å†…å­˜ä½¿ç”¨: 7.21MB (314 bytes/ä»»åŠ¡)
# 
# æ€§èƒ½æå‡: 40å€
```

## æ ¸å¿ƒç‰¹æ€§

### åç¨‹å¹¶å‘æœºåˆ¶ï¼ˆåŸºäºçœŸå®ä»£ç å®ç°ï¼‰

FlowCoroåŸºäºå•ä¸€çš„å¹¶å‘æ–¹å¼ï¼š**Task åˆ›å»ºæ—¶ç«‹å³å¹¶å‘**ï¼Œé€šè¿‡`suspend_never`æœºåˆ¶å®ç°ä»»åŠ¡å¯åŠ¨å³å¹¶å‘æ‰§è¡Œã€‚

#### æ ¸å¿ƒåŸç†ï¼ˆæ¥è‡ª include/flowcoro/core.hï¼‰

```cpp
// FlowCoroçš„çœŸå®å®ç°ï¼šsuspend_never = ç«‹å³æ‰§è¡Œ
template<typename T>
class Task {
public:
    struct promise_type {
        // å…³é”®è®¾è®¡ï¼šsuspend_neverå†³å®šç«‹å³æ‰§è¡Œï¼
        std::suspend_never initial_suspend() { return {}; }
        
        // æ”¯æŒcontinuationçš„final_suspendå®ç°ä»»åŠ¡é“¾
        auto final_suspend() noexcept {
            struct final_awaiter {
                bool await_ready() const noexcept { return false; }
                std::coroutine_handle<> await_suspend(std::coroutine_handle<>) const noexcept {
                    // å½“ä»»åŠ¡å®Œæˆæ—¶ï¼Œæ¢å¤ç­‰å¾…çš„åç¨‹
                    if (promise->continuation) {
                        return promise->continuation;
                    }
                    return std::noop_coroutine();
                }
            };
            return final_awaiter{this};
        }
    };
    
    // awaitå®ç°ï¼šè®¾ç½®continuationè€Œéé˜»å¡
    void await_suspend(std::coroutine_handle<> waiting_handle) {
        // è®¾ç½®continuationï¼šå½“taskå®Œæˆæ—¶æ¢å¤waiting_handle
        handle.promise().set_continuation(waiting_handle);
    }
};
```

#### ä»»åŠ¡æ‰§è¡Œæµç¨‹

```text
1. Taskåˆ›å»º â†’ suspend_never â†’ ç«‹å³æŠ•é€’åˆ°åç¨‹æ± 
2. åç¨‹æ± è°ƒåº¦ â†’ æ— é”é˜Ÿåˆ— â†’ å·¥ä½œçº¿ç¨‹æ‰§è¡Œ
3. ä»»åŠ¡å®Œæˆ â†’ final_suspend â†’ æ¢å¤ç­‰å¾…åç¨‹
4. co_awaitè¿”å› â†’ è·å–ç»“æœ
```

#### è°ƒåº¦ç³»ç»Ÿæ¶æ„

```text
Taskåˆ›å»º â†’ åç¨‹ç®¡ç†å™¨ â†’ æ™ºèƒ½è´Ÿè½½å‡è¡¡ â†’ åç¨‹æ± è°ƒåº¦å™¨ â†’ æ— é”é˜Ÿåˆ— â†’ çº¿ç¨‹æ± æ‰§è¡Œ
   â†“           â†“              â†“              â†“            â†“          â†“
suspend_never  è°ƒåº¦å†³ç­–      é€‰æ‹©æœ€ä¼˜è°ƒåº¦å™¨    ä»»åŠ¡å…¥é˜Ÿ      è·¨çº¿ç¨‹å®‰å…¨   å¹¶å‘æ‰§è¡Œ
```
        //         ^^^^^ è¿™å†³å®šäº†Taskåˆ›å»ºæ—¶ç«‹å³å¼€å§‹æ‰§è¡Œ
        
        std::suspend_always final_suspend() noexcept { return {}; }
        
        Task get_return_object() {
            return Task{std::coroutine_handle<promise_type>::from_promise(*this)};
        }
    };
};

// å®é™…ä½¿ç”¨ï¼šä»»åŠ¡åˆ›å»ºæ—¶çš„å¹¶å‘æœºåˆ¶
Task<void> concurrent_processing() {
    // 1. ä»»åŠ¡å¯åŠ¨ï¼šç«‹å³å¼€å§‹å¹¶å‘æ‰§è¡Œï¼ˆsuspend_neveræœºåˆ¶ï¼‰
    auto task1 = async_compute(1); // ä»»åŠ¡1ç«‹å³å¯åŠ¨
    auto task2 = async_compute(2); // ä»»åŠ¡2ç«‹å³å¯åŠ¨  
    auto task3 = async_compute(3); // ä»»åŠ¡3ç«‹å³å¯åŠ¨
    
    // 2. ç»“æœç­‰å¾…ï¼šæ‰€æœ‰ä»»åŠ¡å·²åœ¨å¹¶å‘æ‰§è¡Œ
    auto result1 = co_await task1; // ç­‰å¾…ä»»åŠ¡1ç»“æœ
    auto result2 = co_await task2; // ç­‰å¾…ä»»åŠ¡2ç»“æœï¼ˆå¯èƒ½å·²å®Œæˆï¼‰
    auto result3 = co_await task3; // ç­‰å¾…ä»»åŠ¡3ç»“æœï¼ˆå¯èƒ½å·²å®Œæˆï¼‰
    
    co_return;
}
```

#### when_all è¯­æ³•ä¾¿åˆ©

```cpp
// when_all åªæ˜¯è¯­æ³•ç³–ï¼Œç®€åŒ–å¤šä»»åŠ¡ç­‰å¾…
Task<void> when_all_example() {
    auto task1 = async_compute(1);
    auto task2 = async_compute(2);
    auto task3 = async_compute(3);
    
    // è¯­æ³•ç³–ï¼šé¿å…æ‰‹åŠ¨è§£æ„å¤šä¸ªç»“æœ
    auto [r1, r2, r3] = co_await when_all(
        std::move(task1),
        std::move(task2), 
        std::move(task3)
    );
    
    // ç­‰ä»·äºä¸Šé¢çš„æ‰‹åŠ¨co_awaitæ–¹å¼
    co_return;
}
```

**é‡è¦è¯´æ˜ï¼š**
- FlowCoroåªæœ‰ä¸€ç§å¹¶å‘æ–¹å¼ï¼š`Taskåˆ›å»ºæ—¶ç«‹å³å¹¶å‘`
- `when_all`ä¸æ˜¯ç‹¬ç«‹çš„å¹¶å‘æœºåˆ¶ï¼Œåªæ˜¯ä¾¿åˆ©çš„è¯­æ³•ç³–
- å†…éƒ¨å®ç°ï¼š`when_all`ä»ç„¶ä½¿ç”¨`co_await`é€ä¸ªç­‰å¾…ä»»åŠ¡
- å¹¶å‘å‘ç”Ÿåœ¨ä»»åŠ¡å¯åŠ¨æ—¶ï¼Œè€Œä¸æ˜¯ç­‰å¾…æ—¶

### åŠ¨æ€å†…å­˜æ± 

```cpp
// è‡ªåŠ¨æ‰©å±•çš„å†…å­˜æ± ï¼Œæ°¸ä¸è¿”å›nullptr
MemoryPool pool(64, 100); // 64å­—èŠ‚å—ï¼Œåˆå§‹100ä¸ª
pool.set_expansion_factor(2.0); // å®¹é‡ä¸è¶³æ—¶æ‰©å±•ä¸º2å€

void* ptr = pool.allocate(); // ä¿è¯æˆåŠŸï¼Œä¼šè‡ªåŠ¨æ‰©å±•
pool.deallocate(ptr); // å®‰å…¨é‡Šæ”¾
```

### é«˜ç²¾åº¦å®šæ—¶å™¨

```cpp
Task<void> timed_operation() {
    auto start = std::chrono::high_resolution_clock::now();

    // é«˜ç²¾åº¦sleep
    co_await sleep_for(std::chrono::milliseconds(100));

    auto duration = std::chrono::high_resolution_clock::now() - start;
    std::cout << "å®é™…è€—æ—¶: " << duration.count() << "ns" << std::endl;
}
```

## æ¶æ„è®¾è®¡

FlowCoroé‡‡ç”¨å…ˆè¿›çš„å¤šçº¿ç¨‹åç¨‹è°ƒåº¦æ¨¡å‹ï¼Œç»“åˆæ™ºèƒ½è´Ÿè½½å‡è¡¡å’Œé«˜æ€§èƒ½å·¥ä½œæ± ï¼š

- **åç¨‹è°ƒåº¦**: å¤šçº¿ç¨‹æ™ºèƒ½è°ƒåº¦å™¨ï¼Œæ”¯æŒè·¨çº¿ç¨‹åç¨‹æ¢å¤
- **CPUä»»åŠ¡**: 32çº¿ç¨‹å·¥ä½œæ± ï¼Œå……åˆ†åˆ©ç”¨å¤šæ ¸æ€§èƒ½  
- **å†…å­˜ç®¡ç†**: åŠ¨æ€æ‰©å±•å†…å­˜æ± ï¼Œé›¶å†…å­˜æ³„æ¼
- **æ— é”è®¾è®¡**: å…³é”®è·¯å¾„ä½¿ç”¨æ— é”æ•°æ®ç»“æ„å’ŒåŸå­æ“ä½œ

è¿™ç§è®¾è®¡åœ¨ä¿æŒåç¨‹è½»é‡çº§ç‰¹æ€§çš„åŒæ—¶ï¼Œå®ç°äº†çœŸæ­£çš„å¤šçº¿ç¨‹å¹¶è¡Œå’Œçº¿ç¨‹å®‰å…¨ä¿è¯ã€‚

### åˆ†å±‚æ¶æ„è®¾è®¡

| å±‚çº§ | ç»„ä»¶ | åŠŸèƒ½ | ç‰¹æ€§ |
|------|------|------|------|
| **åº”ç”¨å±‚** | Task<T> | åç¨‹æ¥å£ | ç»Ÿä¸€API |
| | co_await | å¼‚æ­¥ç­‰å¾… | ç­‰å¾…æœºåˆ¶ |
| | when_all() | è¯­æ³•ç³– | ç®€åŒ–å¤šä»»åŠ¡ç­‰å¾… |
| | sleep_for() | å®šæ—¶å™¨ | é«˜ç²¾åº¦å»¶æ—¶ |
| | sync_wait() | åŒæ­¥ç­‰å¾… | é˜»å¡è·å–ç»“æœ |
| **è°ƒåº¦å±‚** | CoroutineManager | åç¨‹ç®¡ç† | æ™ºèƒ½å¤šçº¿ç¨‹è°ƒåº¦ |
| | Ready Queue | å°±ç»ªé˜Ÿåˆ— | O(1)è°ƒåº¦ |
| | Timer Queue | å®šæ—¶å™¨é˜Ÿåˆ— | çº¢é»‘æ ‘å®ç° |
| | SafeCoroutineHandle | å®‰å…¨æ£€æµ‹ | è·¨çº¿ç¨‹ç”Ÿå‘½å‘¨æœŸä¿æŠ¤ |
| | SmartLoadBalancer | è´Ÿè½½å‡è¡¡ | æ™ºèƒ½è°ƒåº¦å™¨é€‰æ‹© |
| **æ‰§è¡Œå±‚** | ThreadPool | å·¥ä½œçº¿ç¨‹æ±  | 32-128å·¥ä½œçº¿ç¨‹ |
| | Work Queue | ä»»åŠ¡é˜Ÿåˆ— | CPUå¯†é›†å‹ä»»åŠ¡ |
| | Load Balancer | è´Ÿè½½å‡è¡¡ | å·¥ä½œçªƒå–ç®—æ³• |
| **èµ„æºå±‚** | MemoryPool | å†…å­˜æ±  | RAIIç®¡ç† |
| | ObjectPool | å¯¹è±¡æ±  | å¯¹è±¡å¤ç”¨ |
| | LockFree Queue | æ— é”é˜Ÿåˆ— | é«˜å¹¶å‘æ•°æ®ç»“æ„ |

### æ ¸å¿ƒæŠ€æœ¯åˆ›æ–°

#### 1. å¤šçº¿ç¨‹åç¨‹è°ƒåº¦æ¨¡å‹

**é—®é¢˜**: ä¼ ç»Ÿåç¨‹åº“è¦ä¹ˆå•çº¿ç¨‹(æ€§èƒ½å—é™)ï¼Œè¦ä¹ˆå¤šçº¿ç¨‹ä¸å®‰å…¨(æ®µé”™è¯¯)

**FlowCoroè§£å†³æ–¹æ¡ˆ**:

```cpp
// åç¨‹è°ƒåº¦ï¼šå¤šçº¿ç¨‹æ™ºèƒ½è°ƒåº¦å™¨ (é«˜æ€§èƒ½+çº¿ç¨‹å®‰å…¨)
void CoroutineManager::schedule_resume(std::coroutine_handle<> handle) {
    // æ™ºèƒ½è´Ÿè½½å‡è¡¡é€‰æ‹©æœ€ä¼˜è°ƒåº¦å™¨
    auto& load_balancer = get_load_balancer();
    size_t scheduler_id = load_balancer.select_scheduler();
    
    // å®‰å…¨çš„è·¨çº¿ç¨‹æ¢å¤
    schedule_coroutine_enhanced(handle);
}
```

// CPUä»»åŠ¡ï¼šå·¥ä½œçªƒå–çº¿ç¨‹æ±  (é«˜æ€§èƒ½)
class WorkStealingThreadPool {
    thread_local WorkerQueue local_queue_; // æ— é”æœ¬åœ°é˜Ÿåˆ—
    GlobalQueue global_queue_; // è´Ÿè½½å‡è¡¡
    // NUMAæ„ŸçŸ¥çš„å·¥ä½œçªƒå–ç®—æ³•
}
```

#### 2. è·¨çº¿ç¨‹åç¨‹æ¢å¤æ”¯æŒ

**ä¼ ç»Ÿé—®é¢˜:**

```cpp
// ä¹‹å‰ï¼šè·¨çº¿ç¨‹åç¨‹æ¢å¤å¯èƒ½å¯¼è‡´æŒ‚æ­»
void await_suspend(std::coroutine_handle<> h) {
    ThreadPool::enqueue([h]() {
        h.resume(); // æ½œåœ¨çš„çº¿ç¨‹å®‰å…¨é—®é¢˜
    });
}
```

**FlowCoroè§£å†³æ–¹æ¡ˆ:**

```cpp
// ç°åœ¨ï¼šå®‰å…¨çš„è·¨çº¿ç¨‹è°ƒåº¦æœºåˆ¶
void await_suspend(std::coroutine_handle<> h) {
    CoroutineManager::get_instance().schedule_resume(h);
    // åç¨‹å¯ä»¥åœ¨ä»»æ„å·¥ä½œçº¿ç¨‹ä¸­å®‰å…¨æ¢å¤
    // æ™ºèƒ½è´Ÿè½½å‡è¡¡ç¡®ä¿æœ€ä¼˜æ€§èƒ½
}
```
```

#### 3. åç¨‹å¹¶å‘æ¨¡å¼æ¾„æ¸…

**FlowCoroçš„å®é™…å®ç°ï¼š**

FlowCoroå®é™…ä¸Šåªæœ‰ä¸€ç§å¹¶å‘æ–¹å¼ï¼š**Task åˆ›å»ºæ—¶ç«‹å³å¹¶å‘**

```cpp
// å®é™…çš„å¹¶å‘æœºåˆ¶ï¼šä»»åŠ¡å¯åŠ¨å³å¹¶å‘
Task<void> real_concurrency() {
    // è¿™ä¸‰ä¸ªä»»åŠ¡å¯åŠ¨åç«‹å³å¹¶å‘æ‰§è¡Œ
    auto task1 = async_compute(1); // ç«‹å³å¯åŠ¨å¹¶å‘æ‰§è¡Œ
    auto task2 = async_compute(2); // ç«‹å³å¯åŠ¨å¹¶å‘æ‰§è¡Œ
    auto task3 = async_compute(3); // ç«‹å³å¯åŠ¨å¹¶å‘æ‰§è¡Œ
    
    // co_awaitåªæ˜¯ç­‰å¾…ç»“æœï¼Œä¸å½±å“å¹¶å‘æ‰§è¡Œ
    auto r1 = co_await task1; // ç­‰å¾…ç»“æœ
    auto r2 = co_await task2; // ç­‰å¾…ç»“æœï¼ˆå¯èƒ½å·²å®Œæˆï¼‰
    auto r3 = co_await task3; // ç­‰å¾…ç»“æœï¼ˆå¯èƒ½å·²å®Œæˆï¼‰
    
    co_return;
}

// when_allçš„å®é™…å®ç°ï¼ˆæ¥è‡ªcore.hï¼‰
template<typename... Tasks>
Task<std::tuple<...>> when_all(Tasks&&... tasks) {
    std::tuple<...> results;
    
    // å†…éƒ¨ä»ç„¶æ˜¯é¡ºåºco_awaitï¼
    ((std::get<Is>(results) = co_await std::forward<Ts>(ts)), ...);
    
    co_return std::move(results);
}
```

**æ¾„æ¸…é”™è¯¯è®¤çŸ¥ï¼š**
- **é”™è¯¯**: when_allæä¾›äº†ä¸åŒçš„å¹¶å‘æœºåˆ¶
- **æ­£ç¡®**: when_allåªæ˜¯co_awaitçš„è¯­æ³•ç³–åŒ…è£…
- **é”™è¯¯**: FlowCoroæœ‰å¤šç§å¹¶å‘æ¨¡å¼
- **æ­£ç¡®**: FlowCoroåªæœ‰ä¸€ç§å¹¶å‘æ–¹å¼ï¼Œå°±æ˜¯ä»»åŠ¡å¯åŠ¨æ—¶çš„è‡ªåŠ¨å¹¶å‘

**æ€§èƒ½æ¥æºï¼š**
- å¹¶å‘æ€§èƒ½æ¥è‡ªä»»åŠ¡å¯åŠ¨æ—¶çš„ç«‹å³æ‰§è¡Œ
- co_await å’Œ when_all éƒ½åªæ˜¯ç­‰å¾…æœºåˆ¶
- çœŸæ­£çš„å¹¶å‘åœ¨Taskåˆ›å»ºæ—¶å°±å·²ç»å¼€å§‹

#### 4. è°ƒåº¦å™¨è®¾è®¡æ¨¡å¼

FlowCoroå€Ÿé‰´äº†å¤šä¸ªä¼˜ç§€çš„å¼‚æ­¥æ¡†æ¶è®¾è®¡ï¼š

- **Node.jsäº‹ä»¶å¾ªç¯**: å•çº¿ç¨‹ + äº‹ä»¶é©±åŠ¨
- **Go runtimeè°ƒåº¦å™¨**: M:Nåç¨‹è°ƒåº¦æ¨¡å‹
- **Rust tokio**: Future + Reactoræ¨¡å¼
- **cppcoroåº“**: C++20åç¨‹çš„å·¥ä¸šçº§å®ç°

```cpp
// FlowCoroçš„drive()æ–¹æ³• 
void CoroutineManager::drive() {
    // 1. å¤„ç†å®šæ—¶å™¨é˜Ÿåˆ—
    process_timer_queue();

    // 2. å¤„ç†å°±ç»ªåç¨‹é˜Ÿåˆ—
    process_ready_queue();

    // 3. æ¸…ç†éœ€è¦é”€æ¯çš„åç¨‹
    process_delayed_destruction();
}
```

### æ¶æ„ç‰¹æ€§

#### 1. é«˜æ•ˆåç¨‹åˆ‡æ¢

```cpp
// åç¨‹çŠ¶æ€ä¿å­˜ - é«˜æ•ˆæŠ½è±¡
struct CoroutineFrame {
    void* instruction_pointer; // æŒ‡ä»¤æŒ‡é’ˆ
    void* stack_pointer; // æ ˆæŒ‡é’ˆ
    // æ— éœ€ä¿å­˜æ•´ä¸ªæ ˆ - åªä¿å­˜å¿…è¦çš„å¯„å­˜å™¨çŠ¶æ€
};
```

#### 2. æ— é”æ•°æ®ç»“æ„

```cpp
// æ— é”å°±ç»ªé˜Ÿåˆ— - æ”¯æŒå¤šç”Ÿäº§è€…å•æ¶ˆè´¹è€…
template<typename T>
class LockFreeQueue {
    std::atomic<Node*> head_{nullptr};
    std::atomic<Node*> tail_{nullptr};

    // CASæ“ä½œå®ç°æ— é”å…¥é˜Ÿ/å‡ºé˜Ÿ
    bool enqueue(T item) noexcept;
    bool dequeue(T& item) noexcept;
};
```

#### 3. çº¿ç¨‹å®‰å…¨æ£€æµ‹æœºåˆ¶

```cpp
class SafeCoroutineHandle {
    std::thread::id creation_thread_; // åˆ›å»ºçº¿ç¨‹ID
    std::atomic<bool> is_valid_; // åŸå­æœ‰æ•ˆæ€§æ ‡è®°

    bool is_current_thread_safe() const {
        return std::this_thread::get_id() == creation_thread_;
    }
};
```

### æ€§èƒ½ä¼˜åŠ¿æ¥æº

#### 1. è½»é‡çº§åç¨‹åˆ‡æ¢

#### 2. æ— é”æ•°æ®ç»“æ„

```cpp
// ä¼ ç»Ÿå¤šçº¿ç¨‹ï¼šéœ€è¦é”åŒæ­¥
std::mutex mtx;
std::queue<Task> task_queue;

void enqueue(Task task) {
    std::lock_guard lock(mtx); // é”å¼€é”€
    task_queue.push(task);
}

// FlowCoroï¼šå•çº¿ç¨‹æ— é”
lockfree::Queue<std::function<void()>> task_queue_;

void schedule(std::coroutine_handle<> h) {
    task_queue_.enqueue([h]() { h.resume(); }); // æ— é”
}
```

## é¡¹ç›®ç»“æ„

```
flowcoro/
â”œâ”€â”€ include/flowcoro/ # å¤´æ–‡ä»¶ç›®å½•
â”‚ â”œâ”€â”€ flowcoro.hpp # ä¸»å¤´æ–‡ä»¶
â”‚ â”œâ”€â”€ core.h # åç¨‹æ ¸å¿ƒåŠŸèƒ½
â”‚ â”œâ”€â”€ thread_pool.h # çº¿ç¨‹æ± å®ç°
â”‚ â”œâ”€â”€ memory_pool.h # åŠ¨æ€å†…å­˜æ± 
â”‚ â”œâ”€â”€ object_pool.h # å¯¹è±¡æ± å¤ç”¨
â”‚ â”œâ”€â”€ lockfree.h # æ— é”æ•°æ®ç»“æ„
â”‚ â”œâ”€â”€ result.h # Resulté”™è¯¯å¤„ç†
â”‚ â”œâ”€â”€ network.h # ç½‘ç»œI/Oæ”¯æŒ
â”‚ â””â”€â”€ simple_db.h # åŸºç¡€æ•°æ®åº“æ“ä½œ
â”œâ”€â”€ src/ # æºæ–‡ä»¶
â”‚ â”œâ”€â”€ globals.cpp # å…¨å±€é…ç½®
â”‚ â”œâ”€â”€ net_impl.cpp # ç½‘ç»œå®ç°
â”‚ â””â”€â”€ coroutine_pool.cpp # åç¨‹æ± å®ç°
â”œâ”€â”€ tests/ # æµ‹è¯•ä»£ç 
â”‚ â”œâ”€â”€ test_core.cpp # æ ¸å¿ƒåŠŸèƒ½æµ‹è¯•
â”‚ â”œâ”€â”€ test_network.cpp # ç½‘ç»œåŠŸèƒ½æµ‹è¯•
â”‚ â”œâ”€â”€ test_database.cpp # æ•°æ®åº“æµ‹è¯•
â”‚ â”œâ”€â”€ test_rpc.cpp # RPCåŠŸèƒ½æµ‹è¯•
â”‚ â””â”€â”€ test_framework.h # æµ‹è¯•æ¡†æ¶
â”œâ”€â”€ benchmarks/ # æ€§èƒ½åŸºå‡†æµ‹è¯•
â”‚ â”œâ”€â”€ accurate_bench.cpp # ç²¾ç¡®åŸºå‡†æµ‹è¯•
â”‚ â””â”€â”€ simple_bench.cpp # ç®€å•åŸºå‡†æµ‹è¯•
â”œâ”€â”€ examples/ # ä½¿ç”¨ç¤ºä¾‹
â”‚ â”œâ”€â”€ hello_world.cpp # åŸºç¡€ç¤ºä¾‹
â”‚ â””â”€â”€ hello_world_concurrent.cpp # å¹¶å‘ç¤ºä¾‹
â”œâ”€â”€ scripts/ # æ„å»ºè„šæœ¬
â”‚ â”œâ”€â”€ build.sh # æ„å»ºè„šæœ¬
â”‚ â””â”€â”€ run_core_test.sh # æ ¸å¿ƒæµ‹è¯•è„šæœ¬
â””â”€â”€ cmake/ # CMakeé…ç½®
    â””â”€â”€ FlowCoroConfig.cmake.in
```

## è¿è¡Œæµ‹è¯•

```bash
# è¿è¡Œæ ¸å¿ƒåŠŸèƒ½æµ‹è¯•
./tests/test_core

# è¿è¡Œæ‰€æœ‰æµ‹è¯•
ctest

# è¿è¡Œæ€§èƒ½åŸºå‡†æµ‹è¯•
./benchmarks/accurate_benchmarks
```

### æµ‹è¯•è¦†ç›–æƒ…å†µ

| ç»„ä»¶ | æµ‹è¯•è¦†ç›– | çŠ¶æ€ |
|------|----------|------|
| Taskæ ¸å¿ƒåŠŸèƒ½ | 95% | å®Œæ•´ |
| çº¿ç¨‹æ± è°ƒåº¦ | 90% | å®Œæ•´ |
| å†…å­˜æ± ç®¡ç† | 85% | å®Œæ•´ |
| æ— é”æ•°æ®ç»“æ„ | 88% | å®Œæ•´ |
| ç½‘ç»œI/O | 75% | åŸºç¡€ |
| é”™è¯¯å¤„ç† | 92% | å®Œæ•´ |

## è®¾è®¡ç›®æ ‡ä¸ä½¿ç”¨åœºæ™¯

### è®¾è®¡ç›®æ ‡

1. **å­¦ä¹ å¯¼å‘**: é€šè¿‡å®ç°ç†è§£C++20åç¨‹åŸç†
2. **æ¥å£ç»Ÿä¸€**: æ¶ˆé™¤Taskç±»å‹é€‰æ‹©å›°æ‰°
3. **å®‰å…¨å¯é **: RAIIç®¡ç†ï¼Œå¼‚å¸¸å®‰å…¨
4. **æ€§èƒ½ä¼˜å…ˆ**: é›¶å¼€é”€æŠ½è±¡ï¼Œæ— é”æ•°æ®ç»“æ„
5. **æ˜“äºä½¿ç”¨**: ç°ä»£C++é£æ ¼ï¼Œç›´è§‚API

### ä½¿ç”¨åœºæ™¯åˆ¤æ–­

```text
é€‰æ‹©FlowCoroçš„åœºæ™¯ï¼š
IOå¯†é›†å‹ï¼šWebæœåŠ¡å™¨ã€APIç½‘å…³ã€æ•°æ®åº“æ“ä½œ
é«˜å¹¶å‘ï¼šéœ€è¦å¤„ç†>1000å¹¶å‘è¿æ¥
ä½å»¶è¿Ÿï¼šå¯¹å“åº”æ—¶é—´æ•æ„Ÿçš„åº”ç”¨
èµ„æºå—é™ï¼šå†…å­˜ã€CPUæœ‰é™çš„ç¯å¢ƒ

ä¸é€‚åˆçš„åœºæ™¯ï¼š
CPUå¯†é›†å‹ï¼šå›¾åƒå¤„ç†ã€ç§‘å­¦è®¡ç®—ã€åŠ å¯†
ä½å¹¶å‘ï¼š<100ä¸ªè¿æ¥çš„ç®€å•åº”ç”¨
é—ç•™ä»£ç ï¼šå¤§é‡ç°æœ‰åŒæ­¥ä»£ç çš„æ”¹é€ 
```

## é€‚ç”¨åœºæ™¯

### ğŸš€ å¼ºçƒˆæ¨èä½¿ç”¨ï¼ˆå·²éªŒè¯é«˜æ€§èƒ½ï¼‰

**æ‰¹é‡ä»»åŠ¡å¤„ç†åœºæ™¯:**
- **Web APIæœåŠ¡å™¨**: 500K+ req/s ååé‡ï¼Œé€‚åˆREST APIã€å¾®æœåŠ¡ç½‘å…³
- **æ•°æ®åº“æ‰¹é‡æ“ä½œ**: æ‰¹é‡æŸ¥è¯¢ã€æ‰¹é‡æ’å…¥ã€æ•°æ®è¿ç§»ä»»åŠ¡
- **æ–‡ä»¶æ‰¹é‡å¤„ç†**: å›¾ç‰‡å‹ç¼©ã€æ—¥å¿—åˆ†æã€æ•°æ®æ¸…æ´—
- **æ¶ˆæ¯æ‰¹é‡å¤„ç†**: æ¶ˆæ¯é˜Ÿåˆ—æ‰¹é‡æ¶ˆè´¹ã€é‚®ä»¶æ‰¹é‡å‘é€

**è¯·æ±‚-å“åº”æ¨¡å¼:**
- **HTTPæœåŠ¡å™¨**: æ¯ä¸ªè¯·æ±‚ç‹¬ç«‹å¤„ç†ï¼Œå®Œç¾åŒ¹é…FlowCoroæ¶æ„
- **RPCæœåŠ¡**: gRPCã€Thriftç­‰è¿œç¨‹è°ƒç”¨æœåŠ¡
- **ç¼“å­˜æœåŠ¡**: Redisä»£ç†ã€å†…å­˜ç¼“å­˜æœåŠ¡
- **ä»£ç†ç½‘å…³**: è´Ÿè½½å‡è¡¡å™¨ã€APIç½‘å…³

**é«˜å¹¶å‘ç‹¬ç«‹ä»»åŠ¡:**
- **çˆ¬è™«ç³»ç»Ÿ**: å¤§è§„æ¨¡å¹¶å‘ç½‘é¡µæŠ“å–
- **æµ‹è¯•å·¥å…·**: å‹åŠ›æµ‹è¯•ã€æ€§èƒ½åŸºå‡†æµ‹è¯•
- **æ•°æ®åŒæ­¥**: å¤šæºæ•°æ®åŒæ­¥ä»»åŠ¡

### âŒ ä¸é€‚åˆçš„åœºæ™¯ï¼ˆæ¶æ„é™åˆ¶ï¼‰

**åç¨‹é—´æŒç»­åä½œ:**
- **ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼**: éœ€è¦åç¨‹é—´æŒç»­é€šä¿¡çš„åœºæ™¯
- **æµæ°´çº¿å¤„ç†**: éœ€è¦åç¨‹é“¾å¼åä½œçš„ä»»åŠ¡
- **äº‹ä»¶é©±åŠ¨ç³»ç»Ÿ**: éœ€è¦åç¨‹é—´äº‹ä»¶ä¼ é€’çš„æ¶æ„

**å…¶ä»–ä¸é€‚åˆåœºæ™¯:**
- **CPUå¯†é›†å‹**: ç§‘å­¦è®¡ç®—ã€å›¾åƒå¤„ç†ã€åŠ å¯†ç®—æ³•
- **ä½å¹¶å‘åŒæ­¥**: <100è¿æ¥çš„ç®€å•åŒæ­¥åº”ç”¨  
- **é—ç•™ç³»ç»Ÿæ”¹é€ **: å¤§é‡ç°æœ‰åŒæ­¥ä»£ç çš„å…¨é¢é‡æ„

### ğŸ“Š æ€§èƒ½æ”¶ç›Šé¢„æœŸ

åŸºäºçœŸå®æµ‹è¯•æ•°æ®ï¼Œé€‰æ‹©FlowCoroå¯è·å¾—ï¼š

| æŒ‡æ ‡ | æå‡å€æ•° | å…·ä½“æ•°å€¼ |
|------|----------|----------|
| **æ‰§è¡Œé€Ÿåº¦** | 36.3å€ | 10ms vs 363ms |
| **ååé‡** | 36.3å€ | 1M req/s vs 27K req/s |
| **å†…å­˜æ•ˆç‡** | ä¼˜åŒ– | 407 bytes/task (åŠŸèƒ½ä¸°å¯Œ) |
| **å»¶è¿Ÿé™ä½** | 96å€ | 0.002ms vs 0.193ms |

### ğŸ¯ é€‰æ‹©æŒ‡å—

```cpp
// âœ… æ¨èï¼šæ‰¹é‡å¤„ç†
Task<void> process_requests() {
    std::vector<Task<Response>> tasks;
    
    // æ‰¹é‡åˆ›å»ºä»»åŠ¡ï¼ˆç«‹å³å¼€å§‹å¹¶å‘æ‰§è¡Œï¼‰
    for (const auto& req : requests) {
        tasks.push_back(handle_request(req));
    }
    
    // æ‰¹é‡ç­‰å¾…ç»“æœ
    for (auto& task : tasks) {
        auto response = co_await task;
        process_response(response);
    }
}

// âŒ ä¸æ¨èï¼šæŒç»­åä½œ
Task<void> producer_consumer() {
    auto producer_task = producer();
    auto consumer_task = consumer(); 
    
    // é—®é¢˜ï¼šé¡ºåºæ‰§è¡Œï¼Œä¸æ˜¯çœŸæ­£å¹¶å‘
    co_await producer_task;  // é˜»å¡ç­‰å¾…
    co_await consumer_task;  // ç„¶åæ‰§è¡Œ
}
```

## é«˜çº§ç‰¹æ€§

### è‡ªå®šä¹‰Awaiter

```cpp
class CustomAwaiter {
public:
    bool await_ready() const { return false; }

    void await_suspend(std::coroutine_handle<> handle) {
        // è‡ªå®šä¹‰æŒ‚èµ·é€»è¾‘
        GlobalThreadPool::get_pool().submit([handle]() {
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
            handle.resume();
        });
    }

    void await_resume() { }
};

Task<void> custom_await_demo() {
    co_await CustomAwaiter{};
    std::cout << "è‡ªå®šä¹‰ç­‰å¾…å®Œæˆï¼" << std::endl;
}
```

### åç¨‹ç”Ÿå‘½å‘¨æœŸç®¡ç†

```cpp
class CoroutineManager {
    std::vector<Task<void>> tasks_;

public:
    void add_task(Task<void> task) {
        tasks_.push_back(std::move(task));
    }

    Task<void> wait_all() {
        for (auto& task : tasks_) {
            co_await task;
        }
        tasks_.clear();
    }
};
```

### Resultç±»å‹é”™è¯¯å¤„ç†

```cpp
template<typename T, typename E = std::exception_ptr>
class Result {
    std::variant<T, E> value_;

public:
    bool is_ok() const noexcept;
    T&& unwrap() &&; // ç§»åŠ¨è¯­ä¹‰ä¼˜åŒ–
    E&& unwrap_err() &&;
};

template<typename T>
Task<Result<T, std::string>> safe_execute(Task<T> task) {
    try {
        auto result = co_await task;
        co_return Ok(std::move(result));
    } catch (const std::exception& e) {
        co_return Err(e.what());
    }
}
```

## æ€§èƒ½åŸºå‡†æ•°æ®

### å®é™…æµ‹è¯•ç»“æœ

**æœ€æ–°ç‹¬ç«‹è¿›ç¨‹æµ‹è¯•ç»“æœ (2025-07-25):**

**1000ä¸ªå¹¶å‘è¯·æ±‚ç»ˆææµ‹è¯•:**

- **FlowCoroåç¨‹**: 2ms å®Œæ•´è¿›ç¨‹è€—æ—¶ï¼Œ**500,000 req/s** è¶…é«˜ååé‡
- **ä¼ ç»Ÿå¤šçº¿ç¨‹**: 193ms å®Œæ•´è¿›ç¨‹è€—æ—¶ï¼Œ5,181 req/s ååé‡
- **æ€§èƒ½æå‡**: åç¨‹æ¯”å¤šçº¿ç¨‹å¿« **96.5å€** (æå‡9550%)

**å†…å­˜ä½¿ç”¨å¯¹æ¯” (1000è¯·æ±‚):**

- **åç¨‹å†…å­˜å¢é•¿**: 256KB (262 bytes/è¯·æ±‚)
- **å¤šçº¿ç¨‹å†…å­˜å¢é•¿**: 760KB (778 bytes/è¯·æ±‚)
- **å†…å­˜æ•ˆç‡**: åç¨‹å†…å­˜ä½¿ç”¨æ¯”å¤šçº¿ç¨‹èŠ‚çœ **66%**

**å»¶è¿Ÿå¯¹æ¯”åˆ†æ:**

- **åç¨‹å¹³å‡å»¶è¿Ÿ**: 0.002ms/è¯·æ±‚
- **å¤šçº¿ç¨‹å¹³å‡å»¶è¿Ÿ**: 0.193ms/è¯·æ±‚
- **å»¶è¿Ÿä¼˜åŠ¿**: åç¨‹å»¶è¿Ÿæ¯”å¤šçº¿ç¨‹ä½ **96å€**

### æ€§èƒ½æµ‹è¯•éªŒè¯

```bash
# éªŒè¯æˆ‘ä»¬çš„æ€§èƒ½æ•°æ®
cd build
./examples/hello_world 100 # 100å¹¶å‘è¯·æ±‚æµ‹è¯•
./examples/hello_world 1000 # 1000å¹¶å‘è¯·æ±‚æµ‹è¯•
```

**æµ‹è¯•æ¶æ„ç‰¹ç‚¹:**

- **å®Œå…¨è¿›ç¨‹éš”ç¦»**: ä½¿ç”¨fork/execæ¶ˆé™¤å†…å­˜æ±¡æŸ“
- **ç²¾ç¡®è®¡æ—¶**: åŒ…å«è¿›ç¨‹å¯åŠ¨/æ‰§è¡Œ/é€€å‡ºçš„å®Œæ•´æ—¶é—´
- **å­—èŠ‚çº§ç›‘æ§**: ç²¾ç¡®çš„å†…å­˜ä½¿ç”¨è·Ÿè¸ª
- **å¤šæ ¸åˆ©ç”¨**: 16æ ¸CPUç¯å¢ƒä¸‹çš„çœŸå®å¤šæ ¸æµ‹è¯•

```bash
cd build
./examples/hello_world 100 # 100å¹¶å‘è¯·æ±‚æµ‹è¯•
./examples/hello_world 1000 # 1000å¹¶å‘è¯·æ±‚æµ‹è¯•
```

## æ€§èƒ½è°ƒä¼˜

### å†…å­˜æ± é…ç½®

```cpp
// é’ˆå¯¹å°å¯¹è±¡ä¼˜åŒ–
MemoryPool small_pool(32, 1000); // 32å­—èŠ‚ï¼Œ1000ä¸ªåˆå§‹å—
small_pool.set_expansion_factor(1.5); // å°å¹…æ‰©å±•

// é’ˆå¯¹å¤§å¯¹è±¡ä¼˜åŒ–
MemoryPool large_pool(1024, 100); // 1KBï¼Œ100ä¸ªåˆå§‹å—
large_pool.set_expansion_factor(2.0); // å¿«é€Ÿæ‰©å±•
```

### çº¿ç¨‹æ± è°ƒä¼˜

```cpp
// è‡ªåŠ¨æ£€æµ‹CPUæ ¸å¿ƒæ•°
auto thread_count = std::thread::hardware_concurrency();
ThreadPool pool(thread_count);

// æˆ–è€…æ‰‹åŠ¨è®¾ç½®
ThreadPool custom_pool(8); // 8ä¸ªå·¥ä½œçº¿ç¨‹
```

## è´¡çŒ®æŒ‡å—

æ¬¢è¿æäº¤issueå’Œpull requestï¼š

1. Forké¡¹ç›®
2. åˆ›å»ºç‰¹æ€§åˆ†æ”¯
3. æäº¤æ›´æ”¹
4. æ¨é€åˆ†æ”¯
5. åˆ›å»ºPull Request

## è®¸å¯è¯

æœ¬é¡¹ç›®é‡‡ç”¨MITè®¸å¯è¯ - æŸ¥çœ‹[LICENSE](LICENSE)äº†è§£è¯¦æƒ…ã€‚

## è‡´è°¢

æ„Ÿè°¢ä»¥ä¸‹å¼€æºé¡¹ç›®æä¾›çš„å­¦ä¹ å‚è€ƒï¼š

- [cppcoro](https://github.com/lewissbaker/cppcoro) - C++åç¨‹åº“å‚è€ƒå®ç°
- [async_simple](https://github.com/alibaba/async_simple) - é˜¿é‡Œå·´å·´åç¨‹åº“
- [liburing](https://github.com/axboe/liburing) - é«˜æ€§èƒ½I/Oåº“

---

**é¡¹ç›®çŠ¶æ€**: æ´»è·ƒå¼€å‘ä¸­ | **æœ€åæ›´æ–°**: 2025å¹´8æœˆ
